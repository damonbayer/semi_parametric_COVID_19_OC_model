gq = generated_quantities(my_model, posterior_samples[1,:,1])[1]
keys(gq)

prob = ODEProblem(seirdc_log_ode!,
    log.([gq[:S][1], gq[:E][1], gq[:I][1], gq[:R][1], gq[:D][1], gq[:I][1]]),
    (0.0, obstimes[end]),
    [gq[:β_t_values][1], gq[:γ], gq[:ν], gq[:IFR_t_values][1]])

β_t_values = gq[:β_t_values]
IFR_t_values = gq[:IFR_t_values]

function param_affect_β_IFR!(integrator)
    ind_t = searchsortedfirst(param_change_times, integrator.t) # Find the index of param_change_times that contains the current timestep
    integrator.p[1] = β_t_values[2:end][ind_t] # Replace β with a new value from β_t_values
    integrator.p[4] = IFR_t_values[2:end][ind_t] # Replace IFR with a new value from IFR_t_values
end

param_callback = PresetTimeCallback(param_change_times, param_affect_β_IFR!, save_positions = (false, false))

# Solve the ODE at intervals of 1.0, could also solve at obstimes
sol_1 = solve(prob, Tsit5(), callback = param_callback, saveat = obstimes, save_start = true, verbose = false)

Array(sol_1)[1,:] - log.(gq[:S])
Array(sol_1)[2,:] == log.(gq[:E])

# Seems to work without remaking the callback function
β_t_values = β_t_values .+ 0.1

Array(sol_1)[1,:] - log.(gq[:S])
Array(sol_1)[2,:] == log.(gq[:E])

sol_2 = solve(prob, Tsit5(), callback = param_callback, saveat = obstimes, save_start = true, verbose = false)

Array(sol_2)[1,:] - log.(gq[:S])
Array(sol_2)[2,:] == log.(gq[:E])